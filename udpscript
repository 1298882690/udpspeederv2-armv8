#!/bin/bash
# udp-tunnel-manager.sh - OpenWRT/Debian/Ubuntu通用udpspeeder+udp2raw管理脚本

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# 全局变量
OS_TYPE=""
ARCH=""
ARCH_DISPLAY=""
INIT_SYSTEM=""
BIN_DIR="/usr/bin"
CONFIG_DIR="/etc/udp-tunnel"
LOG_DIR="/var/log/udp-tunnel"
SERVICE_USER="nobody"
HAS_AES=false
DEPLOY_MODE=""
ROLE=""
SERVICE_PASS=""
SERVER_IP=""
BASE_PORT=""

# 版本配置
UDPSPEEDER_VERSION="20230206.0"
UDP2RAW_VERSION="20230206.0"
REPO_BASE="https://github.com/wangyu-"

# 日志函数
log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_step() { echo -e "${BLUE}[STEP]${NC} $1"; }

# 检测运行环境
detect_environment() {
    log_step "检测系统环境..."
    
    if [ -f "/etc/openwrt_release" ]; then
        OS_TYPE="openwrt"
        BIN_DIR="/usr/bin"
        CONFIG_DIR="/etc/udp-tunnel"
        LOG_DIR="/tmp/udp-tunnel"
        INIT_SYSTEM="procd"
        log_info "检测到OpenWRT系统"
    elif [ -f "/etc/debian_version" ] || [ -f "/etc/lsb-release" ] && grep -q "Ubuntu" /etc/lsb-release 2>/dev/null; then
        if [ -f "/etc/lsb-release" ] && grep -q "Ubuntu" /etc/lsb-release; then
            OS_TYPE="ubuntu"
            log_info "检测到Ubuntu系统"
        else
            OS_TYPE="debian"
            log_info "检测到Debian系统"
        fi
        BIN_DIR="/usr/local/bin"
        CONFIG_DIR="/etc/udp-tunnel"
        LOG_DIR="/var/log/udp-tunnel"
        INIT_SYSTEM="systemd"
    else
        log_error "不支持的操作系统"
        exit 1
    fi
    
    ARCH_RAW=$(uname -m)
    case $ARCH_RAW in
        x86_64|amd64) 
            ARCH="amd64"
            ARCH_DISPLAY="amd64"
            ;;
        aarch64|arm64) 
            ARCH="armv8"
            ARCH_DISPLAY="aarch64/arm64"
            ;;
        armv7l|armhf) 
            ARCH="arm"
            ARCH_DISPLAY="armv7"
            ;;
        mips|mips_be) 
            ARCH="mips_be"
            ARCH_DISPLAY="mips_be"
            ;;
        mipsle|mips_le) 
            ARCH="mips_le"
            ARCH_DISPLAY="mips_le"
            ;;
        *) 
            log_warn "未知架构: $ARCH_RAW，使用通用配置"
            ARCH="generic"
            ARCH_DISPLAY="generic"
            ;;
    esac
    log_info "系统架构: $ARCH_DISPLAY"
    
    detect_aes_support
    mkdir -p $CONFIG_DIR $LOG_DIR
}

# 检测AES指令集支持
detect_aes_support() {
    log_step "检测CPU AES指令集支持..."
    
    HAS_AES=false
    
    if [ "$ARCH" = "armv8" ]; then
        log_info "ARMv8架构使用专用版本，跳过AES检测"
        return
    fi
    
    if command -v cpuid >/dev/null 2>&1; then
        if cpuid | grep -i "aes instruction" | grep -q "true"; then
            HAS_AES=true
            log_info "CPU支持AES指令集 (cpuid检测)"
        fi
    elif grep -q -i "aes" /proc/cpuinfo 2>/dev/null; then
        HAS_AES=true
        log_info "CPU支持AES指令集 (/proc/cpuinfo检测)"
    elif [ -f "/proc/cpuinfo" ] && grep -q "flags" /proc/cpuinfo && grep "flags" /proc/cpuinfo | grep -q -i "aes"; then
        HAS_AES=true
        log_info "CPU支持AES指令集 (flags检测)"
    else
        log_warn "未检测到AES指令集支持，将使用标准版本"
    fi
}

# 获取带AES后缀的文件名
get_aes_filename() {
    local base_name="$1"
    
    if [ "$HAS_AES" != true ]; then
        echo "$base_name"
        return
    fi
    
    case $ARCH in
        amd64)
            echo "${base_name}_hw_aes"
            ;;
        x86|arm|mips_be|mips_le)
            echo "${base_name}_asm_aes"
            ;;
        *)
            echo "$base_name"
            ;;
    esac
}

# 下载函数（支持备用源）
download_with_fallback() {
    local url="$1"
    local output="$2"
    local filename="$3"
    local max_retries=3
    local retry_count=0
    
    local main_url="$url"
    local fallback_url="https://hk.gh-proxy.com/${url#https://}"
    
    while [ $retry_count -lt $max_retries ]; do
        log_info "尝试下载 $filename (尝试 $((retry_count+1))/$max_retries)..."
        
        if wget -q --timeout=20 --tries=2 -O "$output" "$main_url"; then
            log_info "下载成功: $filename"
            return 0
        fi
        
        log_warn "主源下载失败，尝试备用源..."
        
        if wget -q --timeout=20 --tries=2 -O "$output" "$fallback_url"; then
            log_info "备用源下载成功: $filename"
            return 0
        fi
        
        retry_count=$((retry_count+1))
        if [ $retry_count -lt $max_retries ]; then
            log_warn "下载失败，5秒后重试..."
            sleep 5
        fi
    done
    
    log_error "下载失败: $filename"
    return 1
}

# 选择部署模式
select_deploy_mode() {
    log_step "选择部署模式"
    
    echo "请选择部署模式:"
    echo "  1. 只部署 udpspeederv2"
    echo "  2. 只部署 udp2raw"
    echo "  3. 部署 udpspeederv2 + udp2raw (组合模式)"
    read -p "请输入选择 (1/2/3): " MODE_CHOICE
    
    case $MODE_CHOICE in
        1)
            DEPLOY_MODE="speederv2-only"
            log_info "选择: 只部署 udpspeederv2"
            ;;
        2)
            DEPLOY_MODE="udp2raw-only"
            log_info "选择: 只部署 udp2raw"
            ;;
        3)
            DEPLOY_MODE="both"
            log_info "选择: 部署 udpspeederv2 + udp2raw"
            ;;
        *)
            log_error "无效的选择"
            return 1
            ;;
    esac
    
    return 0
}

# 选择角色
select_role() {
    echo "请选择角色:"
    echo "  1. 客户端 (Client)"
    echo "  2. 服务端 (Server)"
    read -p "请输入选择 (1/2): " ROLE_CHOICE
    
    case $ROLE_CHOICE in
        1)
            ROLE="client"
            log_info "配置为客户端"
            read -p "请输入服务器IP地址: " SERVER_IP
            ;;
        2)
            ROLE="server"
            log_info "配置为服务端"
            ;;
        *)
            log_error "无效的选择"
            return 1
            ;;
    esac
    
    read -p "请输入服务密码: " SERVICE_PASS
    read -p "请输入基础端口 (默认: 3333): " BASE_PORT
    BASE_PORT=${BASE_PORT:-3333}
    
    return 0
}

# 下载并安装udpspeederv2
install_speederv2() {
    log_step "下载并安装 udpspeederv2..."
    
    if [ "$ARCH" = "armv8" ]; then
        log_info "检测到ARMv8架构，使用专用版本"
        UDPSPEEDER_URL="https://raw.githubusercontent.com/1298882690/udpspeederv2-armv8/refs/heads/main/udpspeederv2-armv8"
        
        if download_with_fallback "$UDPSPEEDER_URL" "/tmp/speederv2_armv8" "udpspeederv2-armv8"; then
            SPEEDER_BIN="/tmp/speederv2_armv8"
            log_info "udpspeederv2 ARMv8专用版下载成功"
        else
            log_error "udpspeederv2 ARMv8下载失败"
            return 1
        fi
    else
        local speeder_binary="speederv2_$ARCH"
        UDPSPEEDER_URL="${REPO_BASE}UDPspeeder/releases/download/${UDPSPEEDER_VERSION}/${speeder_binary}.tar.gz"
        
        if download_with_fallback "$UDPSPEEDER_URL" "/tmp/speederv2.tar.gz" "speederv2_$ARCH.tar.gz"; then
            log_info "udpspeederv2下载成功"
            tar -xzf /tmp/speederv2.tar.gz -C /tmp/
            SPEEDER_BIN=$(find /tmp -name "speederv2_*" -type f 2>/dev/null | head -1)
        else
            log_error "udpspeederv2下载失败"
            return 1
        fi
    fi
    
    if [ -n "$SPEEDER_BIN" ] && [ -f "$SPEEDER_BIN" ]; then
        install -m 755 "$SPEEDER_BIN" "$BIN_DIR/speederv2"
        log_info "udpspeederv2 安装完成"
        return 0
    else
        log_error "udpspeederv2 二进制文件不存在"
        return 1
    fi
}

# 下载并安装udp2raw
install_udp2raw() {
    log_step "下载并安装 udp2raw..."
    
    if [ "$ARCH" = "armv8" ]; then
        log_info "检测到ARMv8架构，使用专用版本"
        UDP2RAW_URL="https://raw.githubusercontent.com/1298882690/udpspeederv2-armv8/refs/heads/main/udp2raw-armv8"
        
        if download_with_fallback "$UDP2RAW_URL" "/tmp/udp2raw_armv8" "udp2raw-armv8"; then
            UDP2RAW_BIN="/tmp/udp2raw_armv8"
            log_info "udp2raw ARMv8专用版下载成功"
        else
            log_error "udp2raw ARMv8下载失败"
            return 1
        fi
    else
        local udp2raw_binary=$(get_aes_filename "udp2raw_$ARCH")
        UDP2RAW_URL="https://github.com/wangyu-/udp2raw-tunnel/releases/download/${UDP2RAW_VERSION}/${udp2raw_binary}"
        
        if download_with_fallback "$UDP2RAW_URL" "/tmp/$udp2raw_binary" "$udp2raw_binary"; then
            UDP2RAW_BIN="/tmp/$udp2raw_binary"
            log_info "udp2raw下载成功$( [ "$HAS_AES" = true ] && echo " (AES加速版)" )"
        else
            log_error "udp2raw下载失败"
            return 1
        fi
    fi
    
    if [ -n "$UDP2RAW_BIN" ] && [ -f "$UDP2RAW_BIN" ]; then
        install -m 755 "$UDP2RAW_BIN" "$BIN_DIR/udp2raw"
        log_info "udp2raw 安装完成"
        return 0
    else
        log_error "udp2raw 二进制文件不存在"
        return 1
    fi
}

# 功能1: 下载并安装（根据部署模式）
install_binaries() {
    log_step "开始下载并安装..."
    
    select_deploy_mode
    if [ $? -ne 0 ]; then return 1; fi
    
    select_role
    if [ $? -ne 0 ]; then return 1; fi
    
    case $DEPLOY_MODE in
        "speederv2-only")
            install_speederv2
            ;;
        "udp2raw-only")
            install_udp2raw
            ;;
        "both")
            install_speederv2
            if [ $? -eq 0 ]; then
                install_udp2raw
            fi
            ;;
    esac
    
    # 验证安装
    if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        if command -v speederv2 >/dev/null 2>&1; then
            log_info "udpspeederv2 安装验证成功"
            echo "udpspeederv2版本: $(speederv2 -h 2>&1 | head -1)"
        else
            log_error "udpspeederv2 安装验证失败"
            return 1
        fi
    fi
    
    if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        if command -v udp2raw >/dev/null 2>&1; then
            log_info "udp2raw 安装验证成功"
            echo "udp2raw版本: $(udp2raw -h 2>&1 | head -1)"
        else
            log_error "udp2raw 安装验证失败"
            return 1
        fi
    fi
    
    log_info "安装完成！"
    return 0
}

# 生成配置文件
generate_configs() {
    log_step "生成配置文件..."
    
    # 生成udpspeederv2配置
    if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        if [ "$ROLE" = "client" ]; then
            cat > $CONFIG_DIR/speederv2-client.conf << EOF
# udpspeederv2客户端配置
MODE="-c"
LOCAL_PORT="$((BASE_PORT))"
REMOTE_PORT="$((BASE_PORT+1))"
OPTIONS="-l0.0.0.0:\${LOCAL_PORT} -r127.0.0.1:\${REMOTE_PORT} -f20:10 -k\"${SERVICE_PASS}\""
EOF
            log_info "udpspeederv2客户端配置已创建"
        else
            cat > $CONFIG_DIR/speederv2-server.conf << EOF
# udpspeederv2服务端配置
MODE="-s"
LOCAL_PORT="$((BASE_PORT+1))"
REMOTE_PORT="$((BASE_PORT+2))"
OPTIONS="-l0.0.0.0:\${LOCAL_PORT} -r127.0.0.1:\${REMOTE_PORT} -f20:10 -k\"${SERVICE_PASS}\""
EOF
            log_info "udpspeederv2服务端配置已创建"
        fi
    fi
    
    # 生成udp2raw配置
    if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        if [ "$ROLE" = "client" ]; then
            cat > $CONFIG_DIR/udp2raw-client.conf << EOF
# udp2raw客户端配置
MODE="-c"
LOCAL_PORT="$((BASE_PORT+1))"
REMOTE_IP="${SERVER_IP}"
REMOTE_PORT="$((BASE_PORT+2))"
OPTIONS="-l0.0.0.0:\${LOCAL_PORT} -r\${REMOTE_IP}:\${REMOTE_PORT} -k\"${SERVICE_PASS}\" --raw-mode faketcp"
EOF
            log_info "udp2raw客户端配置已创建"
        else
            cat > $CONFIG_DIR/udp2raw-server.conf << EOF
# udp2raw服务端配置
MODE="-s"
LOCAL_PORT="$((BASE_PORT+2))"
REMOTE_PORT="$((BASE_PORT+3))"
OPTIONS="-l0.0.0.0:\${LOCAL_PORT} -r127.0.0.1:\${REMOTE_PORT} -k\"${SERVICE_PASS}\" --raw-mode faketcp"
EOF
            log_info "udp2raw服务端配置已创建"
        fi
    fi
}

# 创建启动脚本
create_startup_scripts() {
    log_step "创建启动脚本..."
    
    # udpspeederv2启动脚本
    if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        cat > $BIN_DIR/start-speederv2.sh << 'EOF'
#!/bin/bash
CONFIG_DIR="/etc/udp-tunnel"
LOG_DIR="/var/log/udp-tunnel"

if [ "$ROLE" = "client" ] && [ -f "$CONFIG_DIR/speederv2-client.conf" ]; then
    source $CONFIG_DIR/speederv2-client.conf
elif [ "$ROLE" = "server" ] && [ -f "$CONFIG_DIR/speederv2-server.conf" ]; then
    source $CONFIG_DIR/speederv2-server.conf
else
    echo "未找到udpspeederv2配置文件"
    exit 1
fi

echo "启动udpspeederv2 ($ROLE)..."
CMD="speederv2 $MODE $OPTIONS"
echo "执行命令: $CMD"
eval $CMD > $LOG_DIR/speederv2.log 2>&1 &
SPEEDER_PID=$!

echo $SPEEDER_PID > /var/run/speederv2.pid
echo "udpspeederv2启动完成，PID: $SPEEDER_PID"
EOF
        chmod +x $BIN_DIR/start-speederv2.sh
        log_info "udpspeederv2启动脚本已创建"
    fi
    
    # udp2raw启动脚本
    if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        cat > $BIN_DIR/start-udp2raw.sh << 'EOF'
#!/bin/bash
CONFIG_DIR="/etc/udp-tunnel"
LOG_DIR="/var/log/udp-tunnel"

if [ "$ROLE" = "client" ] && [ -f "$CONFIG_DIR/udp2raw-client.conf" ]; then
    source $CONFIG_DIR/udp2raw-client.conf
elif [ "$ROLE" = "server" ] && [ -f "$CONFIG_DIR/udp2raw-server.conf" ]; then
    source $CONFIG_DIR/udp2raw-server.conf
else
    echo "未找到udp2raw配置文件"
    exit 1
fi

echo "启动udp2raw ($ROLE)..."
CMD="udp2raw $MODE $OPTIONS"
echo "执行命令: $CMD"
eval $CMD > $LOG_DIR/udp2raw.log 2>&1 &
UDP2RAW_PID=$!

echo $UDP2RAW_PID > /var/run/udp2raw.pid
echo "udp2raw启动完成，PID: $UDP2RAW_PID"
EOF
        chmod +x $BIN_DIR/start-udp2raw.sh
        log_info "udp2raw启动脚本已创建"
    fi
}

# 创建systemd服务
create_systemd_services() {
    log_step "创建systemd服务..."
    
    # udpspeederv2服务
    if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        cat > /etc/systemd/system/speederv2.service << EOF
[Unit]
Description=UDPspeeder v2 Service
After=network.target
Wants=network.target

[Service]
Type=forking
Environment=ROLE=$ROLE
ExecStart=$BIN_DIR/start-speederv2.sh
ExecStop=/bin/kill -TERM \$(cat /var/run/speederv2.pid 2>/dev/null)
Restart=always
RestartSec=10
User=$SERVICE_USER

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
        systemctl enable speederv2.service
        log_info "udpspeederv2 systemd服务已创建"
    fi
    
    # udp2raw服务
    if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        cat > /etc/systemd/system/udp2raw.service << EOF
[Unit]
Description=UDP2Raw Tunnel Service
After=network.target
Wants=network.target

[Service]
Type=forking
Environment=ROLE=$ROLE
ExecStart=$BIN_DIR/start-udp2raw.sh
ExecStop=/bin/kill -TERM \$(cat /var/run/udp2raw.pid 2>/dev/null)
Restart=always
RestartSec=10
User=$SERVICE_USER

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
        systemctl enable udp2raw.service
        log_info "udp2raw systemd服务已创建"
    fi
}

# 创建procd服务 (OpenWRT)
create_procd_services() {
    log_step "创建procd服务..."
    
    # udpspeederv2服务
    if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        cat > /etc/init.d/speederv2 << EOF
#!/bin/sh /etc/rc.common

START=99
STOP=10
USE_PROCD=1

start_service() {
    procd_open_instance
    procd_set_param command \$BIN_DIR/start-speederv2.sh
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param respawn
    procd_close_instance
}

stop_service() {
    kill \$(cat /var/run/speederv2.pid 2>/dev/null) 2>/dev/null
    rm -f /var/run/speederv2.pid
}
EOF
        chmod +x /etc/init.d/speederv2
        /etc/init.d/speederv2 enable
        log_info "udpspeederv2 procd服务已创建"
    fi
    
    # udp2raw服务
    if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        cat > /etc/init.d/udp2raw << EOF
#!/bin/sh /etc/rc.common

START=100
STOP=10
USE_PROCD=1

start_service() {
    procd_open_instance
    procd_set_param command \$BIN_DIR/start-udp2raw.sh
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param respawn
    procd_close_instance
}

stop_service() {
    kill \$(cat /var/run/udp2raw.pid 2>/dev/null) 2>/dev/null
    rm -f /var/run/udp2raw.pid
}
EOF
        chmod +x /etc/init.d/udp2raw
        /etc/init.d/udp2raw enable
        log_info "udp2raw procd服务已创建"
    fi
}

# 功能2: 配置系统服务
configure_services() {
    log_step "配置系统服务..."
    
    if [ -z "$DEPLOY_MODE" ] || [ -z "$ROLE" ]; then
        log_error "请先执行选项1 (安装二进制文件) 来设置部署模式和角色"
        return 1
    fi
    
    generate_configs
    create_startup_scripts
    
    case $INIT_SYSTEM in
        systemd)
            create_systemd_services
            ;;
        procd)
            create_procd_services
            ;;
    esac
    
    log_info "服务配置完成"
    
    # 显示配置摘要
    echo "========================================="
    echo "配置摘要:"
    echo "  部署模式: $DEPLOY_MODE"
    echo "  角色: $ROLE"
    echo "  基础端口: $BASE_PORT"
    if [ "$ROLE" = "client" ]; then
        echo "  服务器IP: $SERVER_IP"
    fi
    echo "  配置文件: $CONFIG_DIR/"
    echo "  日志目录: $LOG_DIR/"
    echo "========================================="
}

# 启动服务
start_services() {
    log_step "启动服务..."
    
    case $INIT_SYSTEM in
        systemd)
            if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                systemctl start speederv2.service
                sleep 2
            fi
            if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                systemctl start udp2raw.service
                sleep 2
            fi
            ;;
        procd)
            if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                /etc/init.d/speederv2 start
                sleep 2
            fi
            if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                /etc/init.d/udp2raw start
                sleep 2
            fi
            ;;
    esac
    
    check_status
}

# 停止服务
stop_services() {
    log_step "停止服务..."
    
    case $INIT_SYSTEM in
        systemd)
            if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                systemctl stop speederv2.service
            fi
            if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                systemctl stop udp2raw.service
            fi
            ;;
        procd)
            if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                /etc/init.d/speederv2 stop
            fi
            if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                /etc/init.d/udp2raw stop
            fi
            ;;
    esac
    
    sleep 1
    check_status
}

# 重启服务
restart_services() {
    log_step "重启服务..."
    
    stop_services
    sleep 2
    start_services
}

# 功能3: 检测运行状态
check_status() {
    log_step "检测服务运行状态..."
    
    echo "=== 进程状态 ==="
    
    # udpspeederv2状态
    if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        if pgrep -x "speederv2" >/dev/null; then
            echo -e "udpspeederv2: ${GREEN}运行中${NC} (PID: $(pgrep -x speederv2))"
        else
            echo -e "udpspeederv2: ${RED}未运行${NC}"
        fi
    fi
    
    # udp2raw状态
    if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        if pgrep -x "udp2raw" >/dev/null; then
            echo -e "udp2raw: ${GREEN}运行中${NC} (PID: $(pgrep -x udp2raw))"
        else
            echo -e "udp2raw: ${RED}未运行${NC}"
        fi
    fi
    
    echo -e "\n=== 端口监听状态 ==="
    echo "udp/tcp端口监听:"
    
    PIDS=""
    if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        SPEEDER_PID=$(pgrep -x speederv2 2>/dev/null)
        if [ -n "$SPEEDER_PID" ]; then
            PIDS="$PIDS|$SPEEDER_PID"
        fi
    fi
    
    if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
        UDP2RAW_PID=$(pgrep -x udp2raw 2>/dev/null)
        if [ -n "$UDP2RAW_PID" ]; then
            PIDS="$PIDS|$UDP2RAW_PID"
        fi
    fi
    
    if [ -n "$PIDS" ]; then
        PIDS=${PIDS#|}  # 移除开头的|
        netstat -tunpl 2>/dev/null | grep -E "udp|tcp" | grep -E "$PIDS" || echo "未找到相关端口监听"
    else
        echo "无相关进程运行"
    fi
    
    echo -e "\n=== 配置文件状态 ==="
    ls -la $CONFIG_DIR/ 2>/dev/null | grep -E "\.conf$" || echo "无配置文件"
    
    echo -e "\n=== 日志文件状态 ==="
    ls -la $LOG_DIR/ 2>/dev/null | grep -E "\.log$" | head -10 || echo "无日志文件"
    
    echo -e "\n=== 系统服务状态 ==="
    case $INIT_SYSTEM in
        systemd)
            if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                systemctl status speederv2.service --no-pager | head -5
            fi
            if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                systemctl status udp2raw.service --no-pager | head -5
            fi
            ;;
        procd)
            if [ "$DEPLOY_MODE" = "speederv2-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                /etc/init.d/speederv2 status 2>/dev/null || echo "speederv2服务状态检查失败"
            fi
            if [ "$DEPLOY_MODE" = "udp2raw-only" ] || [ "$DEPLOY_MODE" = "both" ]; then
                /etc/init.d/udp2raw status 2>/dev/null || echo "udp2raw服务状态检查失败"
            fi
            ;;
    esac
}

# 功能4: 查看日志
view_logs() {
    log_step "查看服务日志..."
    
    echo "请选择要查看的日志:"
    if [ "$DEPLOY_MODE" = "both" ]; then
        echo "  1. udpspeederv2日志"
        echo "  2. udp2raw日志"
        echo "  3. 系统服务日志"
        echo "  4. 所有日志"
        read -p "请输入选择 (1-4): " LOG_CHOICE
    elif [ "$DEPLOY_MODE" = "speederv2-only" ]; then
        echo "  1. udpspeederv2日志"
        echo "  2. 系统服务日志"
        read -p "请输入选择 (1-2): " LOG_CHOICE
    elif [ "$DEPLOY_MODE" = "udp2raw-only" ]; then
        echo "  1. udp2raw日志"
        echo "  2. 系统服务日志"
        read -p "请输入选择 (1-2): " LOG_CHOICE
    else
        log_error "未设置部署模式"
        return 1
    fi
    
    case $LOG_CHOICE in
        1)
            if [ -f "$LOG_DIR/speederv2.log" ]; then
                tail -50 $LOG_DIR/speederv2.log
            else
                log_error "udpspeederv2日志不存在"
            fi
            ;;
        2)
            if [ "$DEPLOY_MODE" = "both" ]; then
                if [ -f "$LOG_DIR/udp2raw.log" ]; then
                    tail -50 $LOG_DIR/udp2raw.log
                else
                    log_error "udp2raw日志不存在"
                fi
            else
                # 系统服务日志
                case $INIT_SYSTEM in
                    systemd)
                        if [ "$DEPLOY_MODE" = "speederv2-only" ]; then
                            journalctl -u speederv2.service -n 50 --no-pager
                        elif [ "$DEPLOY_MODE" = "udp2raw-only" ]; then
                            journalctl -u udp2raw.service -n 50 --no-pager
                        fi
                        ;;
                    procd)
                        log_warn "OpenWRT请手动查看日志: cat $LOG_DIR/*.log"
                        cat $LOG_DIR/*.log 2>/dev/null | tail -50 || echo "无日志内容"
                        ;;
                esac
            fi
            ;;
        3)
            if [ "$DEPLOY_MODE" = "both" ]; then
                case $INIT_SYSTEM in
                    systemd)
                        journalctl -u speederv2.service -u udp2raw.service -n 50 --no-pager
                        ;;
                    procd)
                        log_warn "OpenWRT请手动查看日志"
                        cat $LOG_DIR/*.log 2>/dev/null | tail -50 || echo "无日志内容"
                        ;;
                esac
            fi
            ;;
        4)
            if [ "$DEPLOY_MODE" = "both" ]; then
                echo "=== udpspeederv2日志 ==="
                tail -20 $LOG_DIR/speederv2.log 2>/dev/null || echo "无udpspeederv2日志"
                echo -e "\n=== udp2raw日志 ==="
                tail -20 $LOG_DIR/udp2raw.log 2>/dev/null || echo "无udp2raw日志"
            fi
            ;;
        *)
            log_error "无效的选择"
            ;;
    esac
}

# 卸载服务
uninstall_services() {
    log_step "卸载服务..."
    
    read -p "确认要卸载吗? (y/N): " CONFIRM
    if [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
        log_info "取消卸载"
        return
    fi
    
    stop_services
    
    # 根据部署模式卸载相应服务
    case $DEPLOY_MODE in
        "speederv2-only")
            services=("speederv2")
            binaries=("speederv2")
            ;;
        "udp2raw-only")
            services=("udp2raw")
            binaries=("udp2raw")
            ;;
        "both")
            services=("speederv2" "udp2raw")
            binaries=("speederv2" "udp2raw")
            ;;
        *)
            log_error "未知的部署模式"
            return 1
            ;;
    esac
    
    for service in "${services[@]}"; do
        case $INIT_SYSTEM in
            systemd)
                systemctl stop ${service}.service 2>/dev/null
                systemctl disable ${service}.service 2>/dev/null
                rm -f /etc/systemd/system/${service}.service
                ;;
            procd)
                /etc/init.d/${service} stop 2>/dev/null
                /etc/init.d/${service} disable 2>/dev/null
                rm -f /etc/init.d/${service}
                ;;
        esac
    done
    
    for binary in "${binaries[@]}"; do
        rm -f $BIN_DIR/${binary} $BIN_DIR/start-${binary}.sh
    done
    
    rm -f /var/run/*.pid
    log_info "服务卸载完成"
    
    # 询问是否删除配置和日志文件
    read -p "是否删除配置和日志文件? (y/N): " DEL_FILES
    if [ "$DEL_FILES" = "y" ] || [ "$DEL_FILES" = "Y" ]; then
        rm -rf $CONFIG_DIR $LOG_DIR
        log_info "配置和日志文件已删除"
    fi
}

# 主菜单
show_menu() {
    clear
    echo "========================================="
    echo "  UDP隧道管理脚本 (独立服务版)"
    echo "========================================="
    echo "当前系统: $OS_TYPE | 架构: $ARCH_DISPLAY"
    echo "AES加速: $([ "$HAS_AES" = true ] && echo "支持" || echo "不支持")"
    if [ -n "$DEPLOY_MODE" ]; then
        echo "部署模式: $DEPLOY_MODE"
        echo "角色: $ROLE | 基础端口: ${BASE_PORT:-未设置}"
    fi
    echo "-----------------------------------------"
    echo "  1. 下载并安装二进制文件"
    echo "  2. 配置系统服务"
    echo "  3. 检测运行状态"
    echo "  4. 查看服务日志"
    echo "  5. 启动服务"
    echo "  6. 停止服务"
    echo "  7. 重启服务"
    echo "  8. 卸载服务"
    echo "  0. 退出"
    echo "========================================="
}

# 主函数
main() {
    detect_environment
    
    while true; do
        show_menu
        read -p "请选择操作 (0-8): " CHOICE
        
        case $CHOICE in
            1)
                install_binaries
                ;;
            2)
                configure_services
                ;;
            3)
                check_status
                ;;
            4)
                view_logs
                ;;
            5)
                start_services
                ;;
            6)
                stop_services
                ;;
            7)
                restart_services
                ;;
            8)
                uninstall_services
                ;;
            0)
                log_info "退出脚本"
                exit 0
                ;;
            *)
                log_error "无效的选择"
                ;;
        esac
        
        echo -e "\n按回车键继续..."
        read
    done
}

# 脚本入口
main "$@"
