#!/bin/bash
# udp-tunnel-manager.sh - OpenWRT/Debian/Ubuntu通用udpspeeder+udp2raw管理脚本

set -e  # 遇到错误立即退出

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 系统检测变量
OS_TYPE=""
ARCH=""
ARCH_RAW=""
INIT_SYSTEM=""
BIN_DIR="/usr/bin"
CONFIG_DIR="/etc/udp-tunnel"
LOG_DIR="/var/log/udp-tunnel"
SERVICE_USER="nobody"
HAS_AES=false

# 版本配置
UDPSPEEDER_VERSION="20230206.0"
UDP2RAW_VERSION="20230206.0"
REPO_BASE="https://github.com/wangyu-"

# 日志函数
log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_step() { echo -e "${BLUE}[STEP]${NC} $1"; }

# 检测运行环境
detect_environment() {
    log_step "检测系统环境..."
    
    # 检测操作系统（更新：添加Ubuntu支持）
    if [ -f "/etc/openwrt_release" ]; then
        OS_TYPE="openwrt"
        BIN_DIR="/usr/bin"
        CONFIG_DIR="/etc/udp-tunnel"
        LOG_DIR="/tmp/udp-tunnel"
        INIT_SYSTEM="procd"
        log_info "检测到OpenWRT系统"
    elif [ -f "/etc/debian_version" ] || [ -f "/etc/lsb-release" ] && grep -q "Ubuntu" /etc/lsb-release 2>/dev/null; then
        # 同时支持Debian和Ubuntu
        if [ -f "/etc/lsb-release" ] && grep -q "Ubuntu" /etc/lsb-release; then
            OS_TYPE="ubuntu"
            log_info "检测到Ubuntu系统"
        else
            OS_TYPE="debian"
            log_info "检测到Debian系统"
        fi
        BIN_DIR="/usr/local/bin"
        CONFIG_DIR="/etc/udp-tunnel"
        LOG_DIR="/var/log/udp-tunnel"
        INIT_SYSTEM="systemd"
    else
        log_error "不支持的操作系统"
        exit 1
    fi
    
    # 检测架构（更新：ARMv8特殊处理）
    ARCH_RAW=$(uname -m)
    case $ARCH_RAW in
        x86_64|amd64) 
            ARCH="amd64"
            ARCH_DISPLAY="amd64"
            ;;
        aarch64|arm64) 
            ARCH="armv8"  # 特殊标记为armv8
            ARCH_DISPLAY="aarch64/arm64"
            ;;
        armv7l|armhf) 
            ARCH="arm"
            ARCH_DISPLAY="armv7"
            ;;
        mips|mips_be) 
            ARCH="mips_be"
            ARCH_DISPLAY="mips_be"
            ;;
        mipsle|mips_le) 
            ARCH="mips_le"
            ARCH_DISPLAY="mips_le"
            ;;
        *) 
            log_warn "未知架构: $ARCH_RAW，使用通用配置"
            ARCH="generic"
            ARCH_DISPLAY="generic"
            ;;
    esac
    log_info "系统架构: $ARCH_DISPLAY (原始: $ARCH_RAW)"
    
    # 检测AES指令集支持（新增功能）
    detect_aes_support
    
    # 创建必要目录
    mkdir -p $CONFIG_DIR $LOG_DIR
}

# 检测AES指令集支持
detect_aes_support() {
    log_step "检测CPU AES指令集支持..."
    
    HAS_AES=false
    # 方法1: 使用cpuid命令
    if command -v cpuid >/dev/null 2>&1; then
        if cpuid | grep -i "aes instruction" | grep -q "true"; then
            HAS_AES=true
            log_info "CPU支持AES指令集 (cpuid检测)"
        fi
    # 方法2: 检查/proc/cpuinfo
    elif grep -q -i "aes" /proc/cpuinfo 2>/dev/null; then
        HAS_AES=true
        log_info "CPU支持AES指令集 (/proc/cpuinfo检测)"
    # 方法3: 检查CPU标志
    elif [ -f "/proc/cpuinfo" ] && grep -q "flags" /proc/cpuinfo && grep "flags" /proc/cpuinfo | grep -q -i "aes"; then
        HAS_AES=true
        log_info "CPU支持AES指令集 (flags检测)"
    else
        log_warn "未检测到AES指令集支持，将使用标准版本"
    fi
    
    if [ "$HAS_AES" = true ]; then
        log_info "将尝试下载AES加速版本"
    fi
}

# 获取带AES后缀的文件名
get_aes_filename() {
    local base_name="$1"
    local aes_suffix=""
    
    case $ARCH in
        amd64)
            aes_suffix="_hw_aes"
            ;;
        x86)
            aes_suffix="_asm_aes"
            ;;
        mips_be|mips_le)
            aes_suffix="_asm_aes"
            ;;
        arm|armv8)
            aes_suffix="_asm_aes"
            ;;
        *)
            aes_suffix=""
            ;;
    esac
    
    if [ "$HAS_AES" = true ] && [ -n "$aes_suffix" ]; then
        echo "${base_name}${aes_suffix}"
    else
        echo "$base_name"
    fi
}

# 下载函数（支持备用源）
download_with_fallback() {
    local url="$1"
    local output="$2"
    local filename="$3"
    local max_retries=3
    local retry_count=0
    
    # 主下载源
    local main_url="$url"
    # 备用下载源（添加代理前缀）
    local fallback_url="https://hk.gh-proxy.com/${url#https://}"
    
    while [ $retry_count -lt $max_retries ]; do
        log_info "尝试下载 $filename (尝试 $((retry_count+1))/$max_retries)..."
        
        # 首先尝试主源
        if wget -q --timeout=20 --tries=2 -O "$output" "$main_url"; then
            log_info "下载成功: $filename"
            return 0
        fi
        
        log_warn "主源下载失败，尝试备用源..."
        
        # 尝试备用源
        if wget -q --timeout=20 --tries=2 -O "$output" "$fallback_url"; then
            log_info "备用源下载成功: $filename"
            return 0
        fi
        
        retry_count=$((retry_count+1))
        if [ $retry_count -lt $max_retries ]; then
            log_warn "下载失败，5秒后重试..."
            sleep 5
        fi
    done
    
    log_error "下载失败: $filename"
    return 1
}

# 功能1: 下载并安装
install_binaries() {
    log_step "开始下载并安装二进制文件..."
    
    # 用户选择角色
    echo "请选择角色:"
    echo "  1. 客户端 (Client)"
    echo "  2. 服务端 (Server)"
    read -p "请输入选择 (1/2): " ROLE_CHOICE
    
    if [ "$ROLE_CHOICE" = "1" ]; then
        ROLE="client"
        log_info "配置为客户端"
    elif [ "$ROLE_CHOICE" = "2" ]; then
        ROLE="server"
        log_info "配置为服务端"
    else
        log_error "无效的选择"
        return 1
    fi
    
    # 下载udpspeeder（特殊处理ARMv8）
    log_info "下载udpspeeder..."
    
    if [ "$ARCH" = "armv8" ]; then
        # ARMv8特殊处理
        log_info "检测到ARMv8架构，使用专用版本"
        UDPSPEEDER_URL="https://raw.githubusercontent.com/1298882690/udpspeederv2-armv8/refs/heads/main/udpspeederv2-armv8"
        UDPSPEEDER_FALLBACK="https://hk.gh-proxy.com/https://raw.githubusercontent.com/1298882690/udpspeederv2-armv8/refs/heads/main/udpspeederv2-armv8"
        
        if download_with_fallback "$UDPSPEEDER_URL" "/tmp/speederv2_armv8" "udpspeederv2-armv8"; then
            SPEEDER_BIN="/tmp/speederv2_armv8"
            log_info "ARMv8专用版下载成功"
        else
            log_error "ARMv8专用版下载失败"
            return 1
        fi
    else
        # 标准架构处理
        local speeder_binary="speederv2_$ARCH"
        UDPSPEEDER_URL="${REPO_BASE}UDPspeeder/releases/download/${UDPSPEEDER_VERSION}/${speeder_binary}.tar.gz"
        
        if download_with_fallback "$UDPSPEEDER_URL" "/tmp/speederv2.tar.gz" "speederv2_$ARCH.tar.gz"; then
            log_info "udpspeeder下载成功"
            tar -xzf /tmp/speederv2.tar.gz -C /tmp/
            SPEEDER_BIN=$(find /tmp -name "speederv2_*" -type f 2>/dev/null | head -1)
        else
            log_error "udpspeeder下载失败"
            return 1
        fi
    fi
    
    # 下载udp2raw（支持AES版本）
    log_info "下载udp2raw..."
    
    # 根据AES支持选择文件名
    local udp2raw_base="udp2raw_$ARCH"
    local udp2raw_binary=$(get_aes_filename "$udp2raw_base")
    
    if [ "$ARCH" = "armv8" ]; then
        # ARMv8可能需要特殊处理，这里先尝试标准命名
        udp2raw_binary="udp2raw_arm"
        if [ "$HAS_AES" = true ]; then
            udp2raw_binary="udp2raw_arm_asm_aes"
        fi
    fi
    
    UDP2RAW_URL="${REPO_BASE}udp2raw-tunnel/releases/download/${UDP2RAW_VERSION}/${udp2raw_binary}"
    
    # 尝试下载AES版本
    if [ "$HAS_AES" = true ]; then
        log_info "尝试下载AES加速版本: $udp2raw_binary"
        if download_with_fallback "$UDP2RAW_URL" "/tmp/$udp2raw_binary" "$udp2raw_binary"; then
            UDP2RAW_BIN="/tmp/$udp2raw_binary"
            log_info "udp2raw AES版本下载成功"
        else
            log_warn "AES版本下载失败，尝试标准版本"
            # 回退到标准版本
            udp2raw_binary="udp2raw_$ARCH"
            UDP2RAW_URL="${REPO_BASE}udp2raw-tunnel/releases/download/${UDP2RAW_VERSION}/${udp2raw_binary}"
            if download_with_fallback "$UDP2RAW_URL" "/tmp/$udp2raw_binary" "$udp2raw_binary"; then
                UDP2RAW_BIN="/tmp/$udp2raw_binary"
                HAS_AES=false  # 更新标记
            else
                log_error "udp2raw下载失败"
                return 1
            fi
        fi
    else
        # 标准版本下载
        if download_with_fallback "$UDP2RAW_URL" "/tmp/$udp2raw_binary" "$udp2raw_binary"; then
            UDP2RAW_BIN="/tmp/$udp2raw_binary"
            log_info "udp2raw标准版本下载成功"
        else
            log_error "udp2raw下载失败"
            return 1
        fi
    fi
    
    # 安装到系统目录
    log_info "安装二进制文件到 $BIN_DIR"
    
    if [ -n "$SPEEDER_BIN" ] && [ -f "$SPEEDER_BIN" ]; then
        install -m 755 "$SPEEDER_BIN" "$BIN_DIR/speederv2"
        log_info "udpspeeder安装完成"
    else
        log_error "udpspeeder二进制文件不存在"
        return 1
    fi
    
    if [ -n "$UDP2RAW_BIN" ] && [ -f "$UDP2RAW_BIN" ]; then
        install -m 755 "$UDP2RAW_BIN" "$BIN_DIR/udp2raw"
        log_info "udp2raw安装完成"
        
        # 显示AES状态
        if [ "$HAS_AES" = true ]; then
            log_info "已安装AES加速版本"
        fi
    else
        log_error "udp2raw二进制文件不存在"
        return 1
    fi
    
    # 验证安装
    if command -v speederv2 >/dev/null 2>&1 && command -v udp2raw >/dev/null 2>&1; then
        log_info "安装成功!"
        echo "udpspeeder版本: $(speederv2 -h 2>&1 | head -1)"
        echo "udp2raw版本: $(udp2raw -h 2>&1 | head -1)"
        
        # 显示架构信息
        if [ "$ARCH" = "armv8" ]; then
            log_info "已安装ARMv8专用版本"
        fi
        return 0
    else
        log_error "安装验证失败"
        return 1
    fi
}

# 后续函数保持不变（configure_services, create_startup_scripts, create_systemd_service, create_procd_service, check_status, view_logs, show_menu, main）
# 由于篇幅限制，这里只展示更新部分，完整脚本需要包含所有原函数

# 主函数
main() {
    # 检测环境
    detect_environment
    
    while true; do
        show_menu
        read -p "请选择操作 (0-7): " CHOICE
        
        case $CHOICE in
            1)
                install_binaries
                ;;
            2)
                if [ -z "$ROLE" ]; then
                    log_error "请先选择角色 (执行选项1)"
                else
                    configure_services
                fi
                ;;
            3)
                check_status
                ;;
            4)
                view_logs
                ;;
            5)
                log_step "启动服务..."
                case $INIT_SYSTEM in
                    systemd)
                        systemctl restart udp-tunnel.service
                        ;;
                    procd)
                        /etc/init.d/udp-tunnel restart
                        ;;
                esac
                sleep 2
                check_status
                ;;
            6)
                log_step "停止服务..."
                case $INIT_SYSTEM in
                    systemd)
                        systemctl stop udp-tunnel.service
                        ;;
                    procd)
                        /etc/init.d/udp-tunnel stop
                        ;;
                esac
                sleep 1
                check_status
                ;;
            7)
                log_step "卸载服务..."
                read -p "确认要卸载吗? (y/N): " CONFIRM
                if [ "$CONFIRM" = "y" ] || [ "$CONFIRM" = "Y" ]; then
                    # 停止服务
                    case $INIT_SYSTEM in
                        systemd)
                            systemctl stop udp-tunnel.service
                            systemctl disable udp-tunnel.service
                            rm -f /etc/systemd/system/udp-tunnel.service
                            systemctl daemon-reload
                            ;;
                        procd)
                            /etc/init.d/udp-tunnel stop
                            /etc/init.d/udp-tunnel disable
                            rm -f /etc/init.d/udp-tunnel
                            ;;
                    esac
                    
                    # 删除文件
                    rm -f $BIN_DIR/speederv2 $BIN_DIR/udp2raw $BIN_DIR/start-udp-tunnel.sh
                    rm -rf $CONFIG_DIR $LOG_DIR
                    rm -f /var/run/udp2raw.pid /var/run/speederv2.pid
                    
                    log_info "卸载完成"
                else
                    log_info "取消卸载"
                fi
                ;;
            0)
                log_info "退出脚本"
                exit 0
                ;;
            *)
                log_error "无效的选择"
                ;;
        esac
        
        echo -e "\n按回车键继续..."
        read
    done
}

# 脚本入口
main "$@"
